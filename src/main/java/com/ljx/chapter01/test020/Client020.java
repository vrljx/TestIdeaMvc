package com.ljx.chapter01.test020;

/**
 * @Created by taylor on 2016/11/7.
 * @DESC    不要只替换一个类
 * 对于final修饰的基本类型和String类型，编译器会认为它是稳定态（Immutable Status），所以在编译时就直接把值编译到字节码中了，避免了在运行期引用（Run-time
 * Reference），以提高代码的执行效率。针对我们的例子来说，Client类在编译时，字节码中就写上了“150”这个常量，而不是一个地址引用，因此无论你后续怎么修改常量类，只要不重新编译Client类，输出还是照旧。 而对于final修饰的类（即非基本类型），编译器认为它是不稳定态（Mutable Status），在编译时建立的则是引用关系（该类型也叫做Soft Final），如果Client类引入的常量是一个类或实例，即使不重新编译也会输出最新值。 千万不可小看了这点知识，细坑也能绊倒大象，比如在一个Web项目中，开发人员修改一个final类型的值（基本类型），考虑到重新发布风险较大，或者是时间较长，或者是审批流程过于繁琐，反正是为了偷懒，于是直接采用替换class类文件的方式发布。替换完毕后应用服务器自动重启，然后简单测试一下（比如本类引用final类型的常量），一切OK。可运行几天后发现业务数据对不上，有的类（引用关系的类）使用了旧值，有的类（继承关系的类）使用的是新值，而且毫无头绪，让人一筹莫展，其实问题的根源就在于此。 恩，还有个小问题没有说明，我们的例子为什么不在IDE工具（比如Eclipse）中运行呢？那是因为在IDE中不能重现该问题，若修改了Constant类，IDE工具会自动编译所有的引用类，“智能”化屏蔽了该问题，但潜在的风险其实仍然存在。 注意　发布应用系统时禁止使用类文件替换方式，整体WAR包发布才是万全之策。
 */
public class Client020 {
    public static void main(String[] args) {
        System.out.println(Constants.MAX_AGE);
    }
}
